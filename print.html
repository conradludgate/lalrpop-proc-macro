<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The little book of nommy</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="nommy.html"><strong aria-hidden="true">1.</strong> nommy</a></li><li class="chapter-item expanded "><a href="ideology.html"><strong aria-hidden="true">2.</strong> Ideology</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="buffers.html"><strong aria-hidden="true">2.1.</strong> Buffers</a></li><li class="chapter-item expanded "><a href="parsers.html"><strong aria-hidden="true">2.2.</strong> Parsers</a></li><li class="chapter-item expanded "><a href="peekers.html"><strong aria-hidden="true">2.3.</strong> Peekers</a></li></ol></li><li class="chapter-item expanded "><a href="basic.html"><strong aria-hidden="true">3.</strong> Basic Parsers</a></li><li class="chapter-item expanded "><a href="derive.html"><strong aria-hidden="true">4.</strong> Derive Parse</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="struct.html"><strong aria-hidden="true">4.1.</strong> Struct</a></li><li class="chapter-item expanded "><a href="enum.html"><strong aria-hidden="true">4.2.</strong> Enum</a></li><li class="chapter-item expanded "><a href="configuration.html"><strong aria-hidden="true">4.3.</strong> Configuration</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="type-attr.html"><strong aria-hidden="true">4.3.1.</strong> Type Attributes</a></li><li class="chapter-item expanded "><a href="field-attr.html"><strong aria-hidden="true">4.3.2.</strong> Field Attributes</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The little book of nommy</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#nommy" id="nommy">nommy</a></h1>
<p><strong>nommy</strong> is a type based parsing crate that features a derive macro to help you utilise the power of rust and nommy</p>
<pre><pre class="playground"><code class="language-rust edition2018">use nommy::{parse, text::*, Parse};

type Letters = AnyOf1&lt;&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;&gt;;

#[derive(Debug, Parse, PartialEq)]
#[nommy(prefix = Tag&lt;&quot;struct&quot;&gt;)]
#[nommy(ignore = WhiteSpace)]
struct StructNamed {
    #[nommy(parser = Letters)]
    name: String,

    #[nommy(prefix = Tag&lt;&quot;{&quot;&gt;, suffix = Tag&lt;&quot;}&quot;&gt;)]
    fields: Vec&lt;NamedField&gt;,
}

#[derive(Debug, Parse, PartialEq)]
#[nommy(suffix = Tag&lt;&quot;,&quot;&gt;)]
#[nommy(ignore = WhiteSpace)]
struct NamedField {
    #[nommy(parser = Letters)]
    name: String,

    #[nommy(prefix = Tag&lt;&quot;:&quot;&gt;, parser = Letters)]
    ty: String,
}

fn main() {
    let input = &quot;struct Foo {
        bar: Abc,
        baz: Xyz,
    }&quot;;

    let struct_: StructNamed = parse(input.chars()).unwrap();
    assert_eq!(
        struct_,
        StructNamed {
            name: &quot;Foo&quot;.to_string(),
            fields: vec![
                NamedField {
                    name: &quot;bar&quot;.to_string(),
                    ty: &quot;Abc&quot;.to_string(),
                },
                NamedField {
                    name: &quot;baz&quot;.to_string(),
                    ty: &quot;Xyz&quot;.to_string(),
                },
            ]
        }
    );
}
</code></pre></pre>
<h1><a class="header" href="#ideology" id="ideology">Ideology</a></h1>
<p><strong>nommy</strong> has three main concepts worth exploring before we get into the usage</p>
<ol>
<li>Buffers</li>
<li>Parsers</li>
<li>Peekers</li>
</ol>
<h1><a class="header" href="#buffers" id="buffers">Buffers</a></h1>
<p><a href="https://docs.rs/nommy/latest/nommy/trait.Buffer.html"><code>Buffer</code></a> is trait that wraps an <code>Iterator</code>. It extends upon this by requiring two extra methods</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// eagerly drops the first `n` elements in the buffer
fn fast_forward(&amp;mut self, n: usize);

/// finds the `i`th element in the iterator, storing any read elements into a buffer for later access
fn peek_ahead(&amp;mut self, i: usize) -&gt; Option&lt;T&gt;
<span class="boring">}
</span></code></pre></pre>
<p>With these two method, the trait can implement a third method, <code>cursor</code> which returns a new <a href="https://docs.rs/nommy/latest/nommy/trait.Buffer.html"><code>Buffer</code></a> type <a href="https://docs.rs/nommy/latest/nommy/struct.Cursor.html"><code>Cursor</code></a>.</p>
<p><a href="https://docs.rs/nommy/latest/nommy/struct.Cursor.html"><code>Cursor</code></a> reads from a buffer only using <code>peek_ahead</code>.
It ensures that any data read through the buffer can be read again in future.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nommy::{Buffer, IntoBuf};
let mut buffer = (0..).into_buf();
let mut cursor1 = buffer.cursor();

// cursors act exactly like an iterator
assert_eq!(cursor1.next(), Some(0));
assert_eq!(cursor1.next(), Some(1));

// cursors can be made from other cursors
let mut cursor2 = cursor1.cursor();
assert_eq!(cursor2.next(), Some(2));
assert_eq!(cursor2.next(), Some(3));

// child cursors do not move the parent's iterator position
assert_eq!(cursor1.next(), Some(2));

assert_eq!(buffer.next(), Some(0));
<span class="boring">}
</span></code></pre></pre>
<p>If you read from a cursor and decide that you won't need to re-read that contents again,
you can call <code>fast_forward_parent</code>. This takes how many elements ahead the <a href="https://docs.rs/nommy/latest/nommy/struct.Cursor.html"><code>Cursor</code></a> has read,
and calls the parent buffer's <code>fast_forward</code> method with it.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nommy::{Buffer, IntoBuf};
let mut input = &quot;foobar&quot;.chars().into_buf();
let mut cursor = input.cursor();
assert_eq!(cursor.next(), Some('f'));
assert_eq!(cursor.next(), Some('o'));
assert_eq!(cursor.next(), Some('o'));

// Typically, the next three calls to `next` would repeat
// the first three calls because cursors read non-destructively.
// However, this method allows to drop the already-read contents
cursor.fast_forward_parent();
assert_eq!(input.next(), Some('b'));
assert_eq!(input.next(), Some('a'));
assert_eq!(input.next(), Some('r'));
<span class="boring">}
</span></code></pre></pre>
<p>The standard implementation of <a href="Buffer"><code>Buffer</code></a> is <a href="https://docs.rs/nommy/latest/nommy/struct.Buf.html"><code>Buf</code></a>, and can be created from any type that implements <code>IntoIterator</code>.</p>
<h1><a class="header" href="#parsers" id="parsers">Parsers</a></h1>
<p><a href="https://docs.rs/nommy/latest/nommy/trait.Parse.html"><code>Parse</code></a> is a trait that defines how to go from a <a href="https://docs.rs/nommy/latest/nommy/trait.Buffer.html"><code>Buffer</code></a> to a value. It is defined as the following</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Parse&lt;T&gt;: Sized {
    fn parse(input: &amp;mut impl Buffer&lt;T&gt;) -&gt; eyre::Result&lt;Self&gt;;
<span class="boring">    
</span><span class="boring">    // Covered in the next section
</span><span class="boring">    fn peek(input: &amp;mut impl Buffer&lt;T&gt;) -&gt; bool {
</span><span class="boring">        Self::parse(input).is_ok()
</span><span class="boring">    }
</span>}
<span class="boring">}
</span></code></pre></pre>
<p><a href="https://docs.rs/nommy/latest/nommy/trait.Parse.html"><code>Parse</code></a> isn't much on it's own, but it's the basis around the rest of this crate. We piggy-back off of <a href="https://crates.io/crates/eyre"><code>eyre</code></a> for error handling, as parsers may have several nested levels of errors and handling those with specific error types can get very complicated.</p>
<h2><a class="header" href="#example" id="example">Example</a></h2>
<p>This example implementation of <a href="https://docs.rs/nommy/latest/nommy/trait.Parse.html"><code>Parse</code></a> reads from a <code>char</code> <a href="https://docs.rs/nommy/latest/nommy/trait.Buffer.html"><code>Buffer</code></a>, parsing a representation of a string.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// StringParser parses a code representation of a string
struct StringParser(String);
impl Parse&lt;char&gt; for StringParser {
    fn parse(input: &amp;mut impl Buffer&lt;char&gt;) -&gt; eyre::Result&lt;Self&gt; {
        // ensure the first character is a quote mark
        if input.next() != Some('\&quot;') {
            return Err(eyre::eyre!(&quot;starting quote not found&quot;));
        }

        let mut output = String::new();
        let mut escaped = false;

        // read from the input until the ending quote is found
        for c in input {
            match (c, escaped) {
                ('\&quot;', true) =&gt; output.push('\&quot;'),
                ('n', true) =&gt; output.push('\n'),
                ('r', true) =&gt; output.push('\r'),
                ('t', true) =&gt; output.push('\t'),
                ('\\', true) =&gt; output.push('\\'),
                (c, true) =&gt; return Err(eyre::eyre!(&quot;unknown escaped character code \\{}&quot;, c)),

                ('\&quot;', false) =&gt; return Ok(Self(output)),
                ('\\', false) =&gt; {
                    escaped = true;
                    continue;
                }
                (c, false) =&gt; output.push(c),
            }
            escaped = false;
        }

        Err(eyre::eyre!(&quot;ending quote not found&quot;))
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#peekers" id="peekers">Peekers</a></h1>
<p>Hidden in the <a href="https://docs.rs/nommy/latest/nommy/trait.Parse.html"><code>Parse</code></a> definition in the previous chapter is the <code>peek</code> method. It's definition is almost exactly the same as <code>parse</code>, but instead of returning <code>Result&lt;Self&gt;</code>, it returns <code>bool</code>. It's supposed to be a faster method of determining whether a given input could be parsed. A lot of the built in parsers utilise [<code>peek</code>] under the hood to resolve branches.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Parse&lt;T&gt;: Sized {
<span class="boring">    fn parse(input: &amp;mut impl Buffer&lt;T&gt;) -&gt; eyre::Result&lt;Self&gt;;
</span><span class="boring">    
</span>    fn peek(input: &amp;mut impl Buffer&lt;T&gt;) -&gt; bool {
        // Default impl - override for better performance
        Self::parse(input).is_ok()
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#example-1" id="example-1">Example</a></h2>
<p>This is the same example from the <a href="parsers.html"><code>Parsers</code></a> section, but instead implementing <code>peek</code>.
It follows a very similar implementation, but avoids a lot of the heavy work, such as dealing with errors
and saving the chars to the string buffer</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// StringParser parses a code representation of a string
struct StringParser(String);
impl Parse&lt;char&gt; for StringParser {
<span class="boring">    fn parse(input: &amp;mut impl Buffer&lt;char&gt;) -&gt; Result&lt;Self&gt; {
</span><span class="boring">        unimplemented!()
</span><span class="boring">    }
</span><span class="boring">    
</span>    fn peek(input: &amp;mut impl Buffer&lt;char&gt;) -&gt; bool {
        // ensure the first character is a quote mark
        if input.next() != Some('\&quot;') {
            return false;
        }

        let mut escaped = false;

        // read from the input until the ending quote is found
        for c in input {
            match (c, escaped) {
                ('\&quot;', true) =&gt; { escaped = false }
                ('n', true) =&gt; { escaped = false }
                ('r', true) =&gt; { escaped = false }
                ('t', true) =&gt; { escaped = false }
                ('\\', true) =&gt; { escaped = false }
                (c, true) =&gt; return false,
                ('\&quot;', false) =&gt; return true,
                ('\\', false) =&gt; { escaped = true; }
                _ =&gt; {},
            }
        }

        false
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#basic-parsers" id="basic-parsers">Basic Parsers</a></h1>
<p><code>nommy</code> provides a set of basic parsers to handle a lot of standard situations. A lot of these makes use of rust's new <a href="https://doc.rust-lang.org/nightly/unstable-book/language-features/const-generics.html"><code>const generics</code></a></p>
<h2><a class="header" href="#tag" id="tag">Tag</a></h2>
<p><a href="https://docs.rs/nommy/latest/nommy/text/struct.Tag.html"><code>Tag</code></a> matches an exact string or byte slice in the input buffer.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use nommy::{IntoBuf, Parse, text::Tag};
</span>let mut buffer = &quot;foobar&quot;.chars().into_buf();
assert!(Tag::&lt;&quot;foo&quot;&gt;::peek(&amp;mut buffer));
assert!(Tag::&lt;&quot;bar&quot;&gt;::peek(&amp;mut buffer));
assert!(buffer.next().is_none());
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#oneof" id="oneof">OneOf</a></h2>
<p><a href="https://docs.rs/nommy/latest/nommy/text/struct.OneOf.html"><code>OneOf</code></a> matches one character or byte that is contained within the pattern string.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use nommy::{IntoBuf, Parse, text::OneOf};
</span>let mut buffer = &quot;bC&quot;.chars().into_buf();
assert_eq!(OneOf::&lt;&quot;abcd&quot;&gt;::parse(&amp;mut buffer).unwrap().into(), 'b');
assert_eq!(OneOf::&lt;&quot;ABCD&quot;&gt;::parse(&amp;mut buffer).unwrap().into(), 'C');
assert!(buffer.next().is_none());
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#anyof" id="anyof">AnyOf</a></h2>
<p><a href="https://docs.rs/nommy/latest/nommy/text/struct.AnyOf.html"><code>AnyOf</code></a> matches as many characters or bytes that are contained within the pattern string as possible.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use nommy::{IntoBuf, Parse, text::AnyOf};
</span>let mut buffer = &quot;dbacCBAD&quot;.chars().into_buf();
assert_eq!(&amp;AnyOf::&lt;&quot;abcd&quot;&gt;::parse(&amp;mut buffer).unwrap().into(), &quot;dbac&quot;);
assert_eq!(&amp;AnyOf::&lt;&quot;ABCD&quot;&gt;::parse(&amp;mut buffer).unwrap().into(), &quot;CBAD&quot;);
assert!(buffer.next().is_none());
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#anyof1" id="anyof1">AnyOf1</a></h2>
<p><a href="https://docs.rs/nommy/latest/nommy/text/struct.AnyOf1.html"><code>AnyOf1</code></a> matches as many characters or bytes that are contained within the pattern string as possible,
requiring at least 1 value to match.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use nommy::{IntoBuf, Parse, text::AnyOf1};
</span>let mut buffer = &quot;dbacCBAD&quot;.chars().into_buf();
assert_eq!(&amp;AnyOf1::&lt;&quot;abcd&quot;&gt;::parse(&amp;mut buffer).unwrap().into(), &quot;dbac&quot;);
assert_eq!(&amp;AnyOf1::&lt;&quot;ABCD&quot;&gt;::parse(&amp;mut buffer).unwrap().into(), &quot;CBAD&quot;);
assert!(buffer.next().is_none());
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#whilenot1" id="whilenot1">WhileNot1</a></h2>
<p><a href="https://docs.rs/nommy/latest/nommy/text/struct.WhileNot1.html"><code>WhileNot1</code></a> matches as many characters or bytes that are <strong>not</strong> contained within the pattern string as possible,
requiring at least 1 value to match.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use nommy::{IntoBuf, Parse, text::WhileNot1};
</span>let mut buffer = &quot;hello world!&quot;.chars().into_buf();
assert_eq!(&amp;WhileNot1::&lt;&quot;.?!&quot;&gt;::parse(&amp;mut buffer).unwrap().into(), &quot;hello world&quot;);
assert_eq!(buffer.next(), Some('!'));
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#vec" id="vec">Vec</a></h2>
<p><code>Vec</code> parses <code>P</code> as many times as it can.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use nommy::{IntoBuf, Parse, text::Tag};
</span>let mut buffer = &quot;...!&quot;.chars().into_buf();
assert_eq!(Vec::&lt;Tag&lt;&quot;.&quot;&gt;&gt;::parse(&amp;mut buffer).unwrap().len(), 3);
assert_eq!(buffer.next(), Some('!'));
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#vec1" id="vec1">Vec1</a></h2>
<p><a href="https://docs.rs/nommy/latest/nommy/struct.Vec1.html"><code>Vec1</code></a> parses <code>P</code> as many times as it can, requiring at least 1 match.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use nommy::{IntoBuf, Parse, Vec1, text::Tag};
</span>let mut buffer = &quot;...!&quot;.chars().into_buf();
assert_eq!(Vec1::&lt;Tag&lt;&quot;.&quot;&gt;&gt;::parse(&amp;mut buffer).unwrap().len(), 3);

// assert_eq!(buffer.next(), Some('!'));
Vec1::&lt;Tag&lt;&quot;.&quot;&gt;&gt;::parse(&amp;mut buffer).unwrap_err()
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#derive-parse" id="derive-parse">Derive Parse</a></h1>
<p>If writing <a href="https://docs.rs/nommy/latest/nommy/trait.Parse.html"><code>Parse</code></a> <code>impl</code>s is getting a bit tiresome for some basic situations,
you can make use of the derive macro provided to implement a lot of standard situations</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use nommy::{IntoBuf, Parse, text::Tag};
</span>#[derive(Parse)]
pub struct FooBar {
    foo: Tag&lt;&quot;foo&quot;&gt;,
    bar: Tag&lt;&quot;bar&quot;&gt;,
}

let mut buffer = &quot;foobar&quot;.chars().into_buf();
assert!(FooBar::peek(&amp;mut buffer));
assert!(buffer.next().is_none());
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#struct" id="struct">Struct</a></h1>
<p>There are 3 different types of <code>struct</code> in rust, all of them are supported by <a href="https://docs.rs/nommy/latest/nommy/derive.Parse.html"><code>derive(Parse)</code></a> in a very similar way</p>
<h2><a class="header" href="#named-struct" id="named-struct">Named Struct</a></h2>
<p>This is the standard <code>struct</code> that people think about,</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use nommy::{Parse};
</span>#[derive(Parse)]
pub struct FooBar {
    foo: Tag&lt;&quot;foo&quot;&gt;,
    bar: Tag&lt;&quot;bar&quot;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>This will parse the text <code>&quot;foo&quot;</code>, then the text <code>&quot;bar&quot;</code>. Order matters. If any single field returns an error when parsing, then the struct returns an error too.</p>
<h2><a class="header" href="#unnamedtuple-struct" id="unnamedtuple-struct">Unnamed/Tuple Struct</a></h2>
<p>Rust also provides <code>unnamed struct</code>s that are essentially the same, but have unnamed fields</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use nommy::{Parse};
</span>#[derive(Parse)]
pub struct FooBar (
    Tag&lt;&quot;foo&quot;&gt;,
    Tag&lt;&quot;bar&quot;&gt;,
);
<span class="boring">}
</span></code></pre></pre>
<p>This parses exactly the same as the named variety</p>
<h2><a class="header" href="#unit-struct" id="unit-struct">Unit Struct</a></h2>
<p>Lastly, rust provides unit structs. While these may seem useless in parsing, they do have uses when you configure how the macro should implement <a href="https://docs.rs/nommy/latest/nommy/trait.Parse.html"><code>Parse</code></a>.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use nommy::{Parse};
</span>#[derive(Parse)]
pub struct Unit;
<span class="boring">}
</span></code></pre></pre>
<p>This currently parses nothing, the <a href="configuration.html">configuration</a> section lets you expand the functionality.</p>
<h1><a class="header" href="#enum" id="enum">Enum</a></h1>
<p>An <code>enum</code>s parser attempts to parse each <code>variant</code>. The first <code>variant</code> that succeeds to parse is the <code>variant</code> that is returned. If no <code>variant</code> could be parsed,
the parser returns an error</p>
<h2><a class="header" href="#example-2" id="example-2">Example</a></h2>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use nommy::{Parse};
</span>#[derive(Parse)]
pub enum FooOrBar {
    Foo(Tag&lt;&quot;foo&quot;&gt;),
    Bar(Tag&lt;&quot;bar&quot;&gt;),
}
<span class="boring">}
</span></code></pre></pre>
<p>This can either parse <code>&quot;foo&quot;</code> or <code>&quot;bar&quot;</code>, but not both.</p>
<h2><a class="header" href="#first-come-first-serve" id="first-come-first-serve">First come first serve</a></h2>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use nommy::{Parse};
</span>#[derive(Parse)]
pub enum OnlyFoo {
    Foo(Tag&lt;&quot;foo&quot;&gt;),
    Foob(Tag&lt;&quot;foob&quot;&gt;),
}
<span class="boring">}
</span></code></pre></pre>
<p>In this example, the <code>OnlyFoo</code> enum can never parse into a variant of <code>Foob</code>. To see why, let's put in the input <code>&quot;foob&quot;</code>.</p>
<p>Since <code>enum</code> parsers try to parse each variant in order, it will first try to parse the <code>Foo</code> variant. This will match the input <code>&quot;foo&quot;</code>, and that is indeed found in the input sequence, therefore the result is <code>OnlyFoo::Foo</code> and the input sequence will have <code>'b'</code> remaining.</p>
<p>One way to solve this is to swap the order, however that might not always be possible. It might be possible to configure greedy evaluation in the future, however that is currently not possible.</p>
<h2><a class="header" href="#variant-types" id="variant-types">Variant types</a></h2>
<p>There are 3 types of variant in a rust <code>enum</code>. These are analagous to the <a href="struct.html"><code>struct</code></a>s described in the previous chapter.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use nommy::{Parse};
</span>#[derive(Parse)]
pub enum ExampleEnum {
    NamedVariant{
        foo: Tag&lt;&quot;foo&quot;&gt;,
        bar: Tag&lt;&quot;bar&quot;&gt;,
    },

    UnnamedVariant(
        Tag&lt;&quot;foo&quot;&gt;,
        Tag&lt;&quot;bar&quot;&gt;,
    ),

    UnitVariant,
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#configuration" id="configuration">Configuration</a></h1>
<p>The <a href="https://docs.rs/nommy/latest/nommy/derive.Parse.html"><code>derive(Parse)</code></a> macro makes use of the <code>nommy</code> attribute to configure how the <a href="https://docs.rs/nommy/latest/nommy/trait.Parse.html"><code>Parse</code></a> implementation is created. There are two different types of attribute. <code>type attributes</code> and <code>field attributes</code>.</p>
<p>If the attribute is on a <code>struct</code>, <code>enum</code> or an <code>enum variant</code> definition, then it will be a <code>type attribute</code>.
Otherwise, if the attribute is on a field definition, it will be a <code>field attribute</code>.</p>
<p>You can repeat many attribute blocks, or repeat attribute rules within the same attribute block, eg:</p>
<pre><code class="language-rust ignore">#[nommy(prefix = Tag&lt;&quot;(&quot;&gt;, suffix = Tag&lt;&quot;)&quot;&gt;)]

// is the same as

#[nommy(prefix = Tag&lt;&quot;(&quot;&gt;)]
#[nommy(suffix = Tag&lt;&quot;)&quot;&gt;)]
</code></pre>
<h2><a class="header" href="#example-3" id="example-3">Example</a></h2>
<p>This code example indicates which attributes are understood as <code>type attributes</code>, and which are <code>field attributes</code></p>
<pre><code class="language-rust ignore"><span class="boring">use nommy::{Parse, text::Tag};
</span>
/// Named struct FooBar
#[derive(Parse)]
#[nommy(&quot;TYPE&quot;, &quot;TYPE&quot;)]
pub struct FooBar {
    #[nommy(&quot;FIELD&quot;)]
    foo: Tag&lt;&quot;foo&quot;&gt;,

    #[nommy(&quot;FIELD&quot;)]
    #[nommy(&quot;FIELD&quot;)]
    bar: Tag&lt;&quot;bar&quot;&gt;,
}

/// Tuple struct Baz123
#[derive(Parse)]
#[nommy(&quot;TYPE&quot;)]
#[nommy(&quot;TYPE&quot;)]
pub struct Baz123 (
    #[nommy(&quot;FIELD&quot;, &quot;FIELD&quot;)]
    Tag&lt;&quot;baz&quot;&gt;,

    #[nommy(&quot;FIELD&quot;)]
    #[nommy(&quot;FIELD&quot;)]
    Tag&lt;&quot;123&quot;&gt;,
);

/// Enum struct FooBarBaz123
#[derive(Parse)]
#[nommy(&quot;TYPE&quot;)]
#[nommy(&quot;TYPE&quot;)]
pub struct FooBarBaz123 (
    #[nommy(&quot;TYPE&quot;)]
    FooBar{
        #[nommy(&quot;FIELD&quot;)]
        foo: Tag&lt;&quot;foo&quot;&gt;,

        #[nommy(&quot;FIELD&quot;)]
        #[nommy(&quot;FIELD&quot;)]
        bar: Tag&lt;&quot;bar&quot;&gt;,
    },

    #[nommy(&quot;TYPE&quot;)]
    Baz123(
        #[nommy(&quot;FIELD&quot;)]
        Tag&lt;&quot;baz&quot;&gt;,

        #[nommy(&quot;FIELD&quot;)]
        #[nommy(&quot;FIELD&quot;)]
        Tag&lt;&quot;123&quot;&gt;,
    ),

    #[nommy(&quot;TYPE&quot;)]
    None,
);
</code></pre>
<h1><a class="header" href="#type-attributes" id="type-attributes">Type Attributes</a></h1>
<p>There's currently only 3 supported type attributes</p>
<h2><a class="header" href="#ignore" id="ignore">Ignore</a></h2>
<p><code>ignore</code> lets you specify how to parse the tokens that you don't care about.</p>
<p>For example, ignoring whitespace:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use nommy::{Parse, IntoBuf, text::{Tag, WhiteSpace}};
</span>#[derive(Parse)]
#[nommy(ignore = WhiteSpace)]
pub struct FooBar(
    Tag&lt;&quot;foo&quot;&gt;,
    Tag&lt;&quot;bar&quot;&gt;,
);

let mut buffer = &quot;foo   bar\t&quot;.chars().into_buf();
FooBar::parse(&amp;mut buffer).unwrap();
// ignore also parses the trailing tokens
assert!(buffer.next().is_none());
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#warning" id="warning">Warning</a></h3>
<p>If the type you give to <code>ignore</code> can parse 0 tokens, then the program will loop forever.
In the future there might be checks in place to automatically exit when empty parsers succeed (or panic?)</p>
<h2><a class="header" href="#prefixsuffix" id="prefixsuffix">Prefix/Suffix</a></h2>
<p><code>prefix</code> and <code>suffix</code> define the parser that you expect to match before we attempt to parse the value we care about.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use nommy::{Parse, IntoBuf, text::Tag};
</span>
#[derive(Parse)]
#[nommy(prefix = Tag&lt;&quot;(&quot;&gt;, suffix = Tag&lt;&quot;)&quot;&gt;)]
pub struct Bracketed(
    Tag&lt;&quot;foo&quot;&gt;,
    Tag&lt;&quot;bar&quot;&gt;,
);

let mut buffer = &quot;(foobar)&quot;.chars().into_buf();
Bracketed::parse(&amp;mut buffer).unwrap();
assert!(buffer.next().is_none());
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#field-attributes" id="field-attributes">Field Attributes</a></h1>
<p>There's currently only 4 supported field attributes</p>
<h2><a class="header" href="#parser" id="parser">Parser</a></h2>
<p><code>parser</code> lets you specify how to parse the input into the type specified.</p>
<p>For example, parsing letters into a string:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use nommy::{Parse, IntoBuf, text::AnyOf1};
</span>
type Letters = AnyOf1&lt;&quot;abcdefghijklmnopqrstuvwxyz&quot;&gt;;

<span class="boring">#[derive(Debug, PartialEq)]
</span>#[derive(Parse)]
pub struct Word (
    #[nommy(parser = Letters)]
    String,
);

let mut buffer = &quot;foo bar&quot;.chars().into_buf();
assert_eq!(Word::parse(&amp;mut buffer).unwrap(), Word(&quot;foo&quot;.to_string()));
<span class="boring">}
</span></code></pre></pre>
<p>This works because <code>Letters</code> implements <code>Into&lt;String&gt;</code>.</p>
<h2><a class="header" href="#prefixsuffix-1" id="prefixsuffix-1">Prefix/Suffix</a></h2>
<p><code>prefix</code> and <code>suffix</code> define the parser that you expect to match before we attempt to parse the value we care about.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use nommy::{Parse, IntoBuf, text::{Tag, AnyOf1, Space}};
</span>
type Numbers = AnyOf1&lt;&quot;0123456789&quot;&gt;;

<span class="boring">#[derive(Debug, PartialEq)]
</span>#[derive(Parse)]
#[nommy(ignore = Space)]
pub struct Add(
    #[nommy(parser = Numbers)]
    String,

    #[nommy(prefix = Tag&lt;&quot;+&quot;&gt;)]
    #[nommy(parser = Numbers)]
    String,
);

let mut buffer = &quot;4 + 7&quot;.chars().into_buf();
assert_eq!(
    Add::parse(&amp;mut buffer).unwrap(),
    Add(&quot;4&quot;.to_string(), &quot;7&quot;.to_string()),
);
assert!(buffer.next().is_none());
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#inner-parser" id="inner-parser">Inner Parser</a></h2>
<p><code>inner_parser</code> lets you specify how to parse the input into the vec type specified.</p>
<p>For example, parsing letters into a string:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use nommy::{Parse, IntoBuf, text::OneOf};
</span>
type Letter = OneOf&lt;&quot;abcdefghijklmnopqrstuvwxyz&quot;&gt;;

<span class="boring">#[derive(Debug, PartialEq)]
</span>#[derive(Parse)]
pub struct Letters (
    #[nommy(inner_parser = Letter)]
    Vec&lt;char&gt;,
);

let mut buffer = &quot;foo bar&quot;.chars().into_buf();
assert_eq!(Letters::parse(&amp;mut buffer).unwrap(), Letters(vec!['f', 'o', 'o']));
<span class="boring">}
</span></code></pre></pre>
<p>This is necessary because <code>Vec&lt;P&gt;</code> <strong>does not</strong> implement <code>Into&lt;Vec&lt;Q&gt;&gt;</code> even if <code>P: Into&lt;Q&gt;</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
